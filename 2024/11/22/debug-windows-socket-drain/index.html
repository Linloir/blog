<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>问题定位回顾 - Windows 上发起 tcp 连接时提示 Only one usage of each socket address (protocol/network address/port) is normally permitted | 時痕</title><meta name="author" content="Linloir"><meta name="copyright" content="Linloir"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="问题背景某天在 Windows 宿主机上执行任务时，发现 wda 指令请求一直失败，查看日志发现唯一有效的错误日志是 Only one usage of each socket address (protocol&#x2F;network address&#x2F;port) is normally permitted，回顾宿主机环境在过去一段时间没有进行过变更，并且该问题是第一次出现，此前相同环境并没有出现过这个问">
<meta property="og:type" content="article">
<meta property="og:title" content="问题定位回顾 - Windows 上发起 tcp 连接时提示 Only one usage of each socket address (protocol&#x2F;network address&#x2F;port) is normally permitted">
<meta property="og:url" content="https://blog.linloir.cn/2024/11/22/debug-windows-socket-drain/">
<meta property="og:site_name" content="時痕">
<meta property="og:description" content="问题背景某天在 Windows 宿主机上执行任务时，发现 wda 指令请求一直失败，查看日志发现唯一有效的错误日志是 Only one usage of each socket address (protocol&#x2F;network address&#x2F;port) is normally permitted，回顾宿主机环境在过去一段时间没有进行过变更，并且该问题是第一次出现，此前相同环境并没有出现过这个问">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.linloir.cn/img/cover.jpg">
<meta property="article:published_time" content="2024-11-22T03:52:37.000Z">
<meta property="article:modified_time" content="2025-05-16T05:33:36.404Z">
<meta property="article:author" content="Linloir">
<meta property="article:tag" content="工作">
<meta property="article:tag" content="问题定位">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.linloir.cn/img/cover.jpg"><link rel="shortcut icon" href="/img/avatar.png"><link rel="canonical" href="https://blog.linloir.cn/2024/11/22/debug-windows-socket-drain/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')
          
          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: false,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '问题定位回顾 - Windows 上发起 tcp 连接时提示 Only one usage of each socket address (protocol/network address/port) is normally permitted',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-16 13:33:36'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="/css/minimal.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-th"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">時痕</span></a><a class="nav-page-title" href="/"><span class="site-name">问题定位回顾 - Windows 上发起 tcp 连接时提示 Only one usage of each socket address (protocol/network address/port) is normally permitted</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-th"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">问题定位回顾 - Windows 上发起 tcp 连接时提示 Only one usage of each socket address (protocol/network address/port) is normally permitted</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-22T03:52:37.000Z" title="发表于 2024-11-22 11:52:37">2024-11-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-16T05:33:36.404Z" title="更新于 2025-05-16 13:33:36">2025-05-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>某天在 Windows 宿主机上执行任务时，发现 wda 指令请求一直失败，查看日志发现唯一有效的错误日志是 <code>Only one usage of each socket address (protocol/network address/port) is normally permitted</code>，回顾宿主机环境在过去一段时间没有进行过变更，并且该问题是第一次出现，此前相同环境并没有出现过这个问题</p>
<p>尝试在其他宿主机以及本地开发机上执行相同命令均不能稳定复现该问题，其中 Linux 开发机无法复现该问题</p>
<p><img src="/img/debug-windows-socket-drain/error_info.png" alt="error info"></p>
<h2 id="定位过程"><a href="#定位过程" class="headerlink" title="定位过程"></a>定位过程</h2><h3 id="报错分析"><a href="#报错分析" class="headerlink" title="报错分析"></a>报错分析</h3><p>由于报错信息只有一行，也只能从这个信息来入手。搜索引擎检索得到如下内容：</p>
<ul>
<li>StackOverflow: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14654998/how-do-i-fix-the-error-only-one-usage-of-each-socket-address-protocol-network">How do I fix the error “Only one usage of each socket address (protocol&#x2F;network address&#x2F;port) is normally permitted”?</a>：文中指出，这个问题可能由多次 <code>listen</code> 同一端口引起，阅读提问者提供的代码确实有此问题</li>
<li>StackOverflow: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/26428827/httpclient-only-one-usage-of-each-socket-address-protocol-network-address-port">HttpClient: Only one usage of each socket address (protocol&#x2F;network address&#x2F;port) is normally permitted</a>：<em>More likely, you are probably posting HTTP requests too often, and maybe not fully consuming the responses, which would prevent ASP from pooling and reusing connections and thus encountering port exhaustion over time</em>，该回答指出如果连接请求过于频繁、没有正确关闭，可能会导致端口耗尽</li>
</ul>
<p>由于此前宿主机并没有暴露出该问题，优先考虑并不是发起请求及接收请求的 client 及 wda 侧的问题，即第一篇文章中提到的可能，而是从宿主机上的 tcp 连接状况入手来进一步分析这个问题，于是主要的关注点转向如下方面：</p>
<ol>
<li>问题出现时，宿主机上的 tcp 连接情况如何，是否存在异常，异常现象怎样？</li>
<li>如果是 tcp 连接问题，为什么 Linux 机器无法复现该问题</li>
</ol>
<h3 id="链路分析"><a href="#链路分析" class="headerlink" title="链路分析"></a>链路分析</h3><p>在开始检查 tcp 连接情况前，首先需要确认大致的请求链路，从而确定需要关注的 tcp 连接范围。问题发生在 Windows 上 docker 容器内服务向宿主机发送 wda 请求时，因此从这一条请求链路入手：</p>
<p>请求的末端是 usbmuxd 服务，该服务负责和连接的 iPhone 进行通信，所有请求最后都会发送到 usbmuxd 来进行多路复用 (multiplexing)，从而达到在一个 usb 链路上同时执行多个请求。</p>
<p>usbmuxd 服务在 Linux 和 Windows 上的表现并不相同，在 Linux 上，其监听一个 UNIX socket 套接字来提供服务，而在 Windows 上，其监听 <code>127.0.0.1:27015</code> 端口提供服务，这里应该是处于安全考虑，其只监听了 <code>127.0.0.1:27015</code> 而不是 <code>0.0.0.0:27015</code>。</p>
<p>由于 Windows 上的 usbmuxd 服务仅监听 <code>127.0.0.1:27015</code> 端口，对于容器内打出来的请求，考虑到其 ip 可能不是 <code>127.0.0.1</code>，遂在宿主机有起一个反代服务，从 <code>0.0.0.0:23333</code> 端口反向代理到 <code>127.0.0.1:27015</code>，这样不是以 <code>127.0.0.1</code> 发起请求的服务可以通过连接到宿主机的 <code>23333</code> 端口来和 usbmuxd 通信。在 Linux 上，同样有这个反代服务，不过它的作用是将请求代理到对应的 UNIX socket 上。</p>
<p>之后就是 docker 内的服务了，其通过 <code>host.docker.internal</code> 域名向宿主机的 <code>23333</code> 端口建立连接，并和 usbmuxd 通信来发送 wda 的请求。</p>
<p>这样，在宿主机上需要关注的连接就很明了了：</p>
<ol>
<li>所有直接向 <code>127.0.0.1:27015</code> 服务发起的通信，包括宿主机对 usbmuxd 服务的请求以及反代服务发起的请求</li>
<li>向宿主机 <code>23333</code> 端口发起的通信</li>
</ol>
<h3 id="tcp-链接分析"><a href="#tcp-链接分析" class="headerlink" title="tcp 链接分析"></a>tcp 链接分析</h3><p>在 Windows 再次复现问题时，使用 <code>netstat -ano | findstr 27015</code> 以及 <code>netstat -ano | findstr 23333</code>，并辅助 <code>| Mesaure-Object</code> 方法来查看连接情况发现：</p>
<ol>
<li>ESTABLISHED 状态连接数正常，差不多在十到百量级，符合当前宿主机负载情况</li>
<li>CLOSED 状态几乎没有</li>
<li>TIME_WAIT 状态非常多，平均在 8000 左右</li>
</ol>
<p>上述现象佐证：</p>
<ol>
<li>宿主机中应该没有发生连接泄露的情况，连接泄露一般表现为 tcp 打开连接后并不正常关闭导致 ESTABLISHED 数量异常增多，此时 ESTABLISHED 状态数正常，故暂时排除这个原因</li>
<li>存在高并发的短连接请求负载，TIME_WAIT 为请求发起方正确通告服务端关闭 tcp 连接后进入的 2MSL 的等待窗口，该标记意味请求已经正常关闭，但是由于短时间内发起量太大导致大量 TIME_WAIT 状态连接堆积</li>
</ol>
<p>联系 <a href="#%E6%8A%A5%E9%94%99%E5%88%86%E6%9E%90">报错分析</a> 中的第二篇参考文章，初步猜测可能由于存在进程大量发起请求，请求结束后 tcp 连接进入 TIME_WAIT 状态，由于没有设置 SO_REUSEADDR 此时端口号仍然处于被占用的状态，如果继续建立连接确实可能会出现端口号用尽导致报错。</p>
<p>这也就引导关注点到如下问题：</p>
<ol>
<li>20000 ~ 65535 这么多端口，怎么会这么快就用尽？<code>netstat -ano | findstr 27015 | findstr | findstr TIME_WAIT | Measure-Object</code> 或是 <code>netstat -ano | findstr 23333 | findstr TIME_WAIT | Measure-Object</code> 反映出来的 TIME_WAIT 连接也不到一万，问题是如何触发的？</li>
<li>是哪个进程在大量发起这样的请求？是否符合预期？</li>
</ol>
<h3 id="Windows-侧动态端口范围分析"><a href="#Windows-侧动态端口范围分析" class="headerlink" title="Windows 侧动态端口范围分析"></a>Windows 侧动态端口范围分析</h3><p>先关注第一个问题，通过检索搜索引擎 <em>windows dynamic port range</em> 可以检索到如下文档：</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/troubleshoot/windows-server/networking/default-dynamic-port-range-tcpip-chang">The default dynamic port range for TCP&#x2F;IP has changed since Windows Vista and in Windows Server 2008</a>：<em>To comply with Internet Assigned Numbers Authority (IANA) recommendations, Microsoft has increased the dynamic client port range for outgoing connections in Windows Vista and Windows Server 2008. The new default start port is 49152, and the new default end port is 65535</em>，也即 Windows 上的默认动态端口范围自 Windows Server 2008 开始，默认从 49152 开始到 65535，一共 16384 个，同时使用 <code>netsh int ipv4 show dynamicport tcp</code> 可以查看实际配置的值</p>
<p>Powershell 执行 <code>netsh int ipv4 show dynamicport tcp</code>，确实得到 <code>16384</code> 这个结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">协议 tcp 动态端口范围</span><br><span class="line">---------------------------------</span><br><span class="line">启动端口        : 49152</span><br><span class="line">端口数          : 16384</span><br></pre></td></tr></table></figure>

<p>联系 <a href="#tcp-%E9%93%BE%E6%8E%A5%E5%88%86%E6%9E%90">tcp 链接分析</a> 中的数量，如果与 <code>27015</code> 和 <code>23333</code> 端口建立的连接数量均达到 8000，确实会有端口耗尽的可能。所以下一步的关键就是：究竟是哪个进程在建立这些连接？是否是自己工程逻辑有问题？</p>
<h3 id="TIME-WAIT-源头分析"><a href="#TIME-WAIT-源头分析" class="headerlink" title="TIME_WAIT 源头分析"></a>TIME_WAIT 源头分析</h3><p>由于 <code>netstat -ano | findstr 27015 | findstr TIME_WAIT</code> 无法展示实际创建连接的 PID，为此我专门写了一个 python 小脚本，这个脚本不断获取非 TIME_WAIT 状态的连接列表来获取连接的 PID，再获取 TIME_WAIT 连接并找到它们原先对应的 PID 输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dictionary to keep track of dual tcp ip:port pair to pid</span></span><br><span class="line">tcp_map = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_tcp_map</span>():</span><br><span class="line">    <span class="keyword">global</span> tcp_map</span><br><span class="line">    <span class="comment"># Execute the command to get established connections</span></span><br><span class="line">    command = <span class="string">&quot;powershell -Command \&quot;netstat -ano | findstr /V TIME_WAIT\&quot;&quot;</span></span><br><span class="line">    result = subprocess.run(command, capture_output=<span class="literal">True</span>, text=<span class="literal">True</span>, shell=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> result.returncode == <span class="number">0</span>:</span><br><span class="line">        lines = result.stdout.strip().split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            parts = line.split()</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(parts) &gt;= <span class="number">5</span>:</span><br><span class="line">                local_address = parts[<span class="number">1</span>]</span><br><span class="line">                remote_address = parts[<span class="number">2</span>]</span><br><span class="line">                pid = parts[<span class="number">4</span>]</span><br><span class="line">                tcp_map[(local_address,remote_address)] = pid</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_time_wait_sockets</span>():</span><br><span class="line">    <span class="keyword">global</span> tcp_map</span><br><span class="line">    <span class="comment"># Execute the command to get TIME_WAIT sockets</span></span><br><span class="line">    command = <span class="string">&quot;powershell -Command \&quot;netstat -ano | findstr TIME_WAIT | findstr /V :443 | findstr /V :80\&quot;&quot;</span></span><br><span class="line">    result = subprocess.run(command, capture_output=<span class="literal">True</span>, text=<span class="literal">True</span>, shell=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> result.returncode == <span class="number">0</span>:</span><br><span class="line">        lines = result.stdout.strip().split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            parts = line.split()</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(parts) &gt;= <span class="number">5</span>:</span><br><span class="line">                local_address = parts[<span class="number">1</span>]</span><br><span class="line">                remote_address = parts[<span class="number">2</span>]</span><br><span class="line">                pid = parts[<span class="number">4</span>]</span><br><span class="line">                <span class="comment"># Check if the TIME_WAIT socket was previously tracked</span></span><br><span class="line">                <span class="keyword">if</span> (local_address,remote_address) <span class="keyword">in</span> tcp_map:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;TIME_WAIT socket: <span class="subst">&#123;local_address&#125;</span> -&gt; <span class="subst">&#123;remote_address&#125;</span>, previously tracked PID: <span class="subst">&#123;tcp_map[(local_address,remote_address)]&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="comment"># Remove the tracked record</span></span><br><span class="line">                    <span class="keyword">del</span> tcp_map[(local_address,remote_address)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signal_handler</span>(<span class="params">sig, frame</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nExiting...&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    signal.signal(signal.SIGINT, signal_handler)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Monitoring TCP connections. Press Ctrl+C to exit.&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        update_tcp_map()</span><br><span class="line">        check_time_wait_sockets()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>脚本写的比较简单，考虑到没有太多干扰连接，直接抓取的所有的 TIME_WAIT 连接的原始 PID，同时过滤了下 <code>443</code> 和 <code>80</code> 这种明显干扰的结果。</p>
<p>同时为了分析 <a href="#%E6%8A%A5%E9%94%99%E5%88%86%E6%9E%90">报错分析</a> 中的第二个问题，同样也写了一份针对 Linux 机器的分析脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dictionary to keep track of dual tcp ip:port pair to pid</span></span><br><span class="line">tcp_map = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_tcp_map</span>():</span><br><span class="line">    <span class="keyword">global</span> tcp_map</span><br><span class="line">    <span class="comment"># Execute the command to get established connections</span></span><br><span class="line">    command = <span class="string">&quot;netstat -anolp | grep -v TIME_WAIT&quot;</span></span><br><span class="line">    result = subprocess.run(command, capture_output=<span class="literal">True</span>, text=<span class="literal">True</span>, shell=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> result.returncode == <span class="number">0</span>:</span><br><span class="line">        lines = result.stdout.strip().split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            parts = line.split()</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(parts) &gt;= <span class="number">7</span>:</span><br><span class="line">                local_address = parts[<span class="number">3</span>]</span><br><span class="line">                remote_address = parts[<span class="number">4</span>]</span><br><span class="line">                pid = parts[<span class="number">6</span>]</span><br><span class="line">                tcp_map[(local_address,remote_address)] = pid</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_time_wait_sockets</span>():</span><br><span class="line">    <span class="keyword">global</span> tcp_map</span><br><span class="line">    <span class="comment"># Execute the command to get TIME_WAIT sockets</span></span><br><span class="line">    command = <span class="string">&quot;netstat -anolp | grep TIME_WAIT&quot;</span></span><br><span class="line">    result = subprocess.run(command, capture_output=<span class="literal">True</span>, text=<span class="literal">True</span>, shell=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> result.returncode == <span class="number">0</span>:</span><br><span class="line">        lines = result.stdout.strip().split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            parts = line.split()</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(parts) &gt;= <span class="number">7</span>:</span><br><span class="line">                local_address = parts[<span class="number">3</span>]</span><br><span class="line">                remote_address = parts[<span class="number">4</span>]</span><br><span class="line">                <span class="comment"># Check if the TIME_WAIT socket was previously tracked</span></span><br><span class="line">                <span class="keyword">if</span> (local_address,remote_address) <span class="keyword">in</span> tcp_map:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;TIME_WAIT socket: <span class="subst">&#123;local_address&#125;</span> -&gt; <span class="subst">&#123;remote_address&#125;</span>, previously tracked PID: <span class="subst">&#123;tcp_map[(local_address,remote_address)]&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="comment"># Remove the tracked record</span></span><br><span class="line">                    <span class="keyword">del</span> tcp_map[(local_address,remote_address)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signal_handler</span>(<span class="params">sig, frame</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nExiting...&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    signal.signal(signal.SIGINT, signal_handler)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Monitoring TCP connections. Press Ctrl+C to exit.&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        update_tcp_map()</span><br><span class="line">        check_time_wait_sockets()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>分析脚本的输出，发现：</p>
<ol>
<li>在 Linux 上，几乎所有的 TIMEWAIT 请求从容器内发出，并与宿主机的反代建立连接。</li>
<li>在 Linux 上单容器任一时刻均会存在约 1000 TIMEWAIT 请求，这一数量与 Windows 上基本保持一致。</li>
<li>在 Windows 上，TIMEWAIT 分为几乎数量完全相同的两个部分：<ol>
<li>由 <code>127.0.0.1</code> 发起的，与反代监听端口建立的连接，PID 查看发起进程为 <code>com.docker.backend.exe</code></li>
<li>由反代进程发起的，与 usbmuxd 监听端口建立的连接</li>
</ol>
</li>
</ol>
<p>其中第一点符合预期，因为在 Linux 上反代通过 UNIX socket 与 usbmuxd 通信，并不经过 tcp 连接。</p>
<p>第二点则提示工程确实存在冗余逻辑，1000 请求量在 120s TIMEWAIT 窗口下代表约 8qps 请求负载，这明显存在逻辑错误，自动化再怎么跑也不应该出现如此高的请求负载。</p>
<p>第三点令人感到疑惑：为什么从 docker 容器内发出的请求实际发起 ip 为 <code>127.0.0.1</code>，并且是由 docker 进程发起的？</p>
<p>由于 Linux 下，请求的发起 ip 均为 docker bridge 网卡下容器的 ip，可以推断 Linux 下容器内发起的请求不会占用宿主机的动态端口。而如果 Windows 会由 docker 代为发起请求，从现象上看起来确实是会占用宿主机的端口范围，这很有可能是 Linux 上无法复现这个问题的，除了 Linux 上与 usbmuxd 通信不使用 tcp 连接之外的另一个关键原因。</p>
<p>至此，可以产生一些阶段性的结论：</p>
<ol>
<li>工程逻辑一定是存在问题需要优化，8qps 请求压力不合理。</li>
<li>问题大概率是由于端口耗尽问题引起，Linux 由于 docker 容器网络与 Windows 原理不同不占用宿主机端口，同时与 usbmuxd 也不占用端口，因此不存在这个问题。</li>
</ol>
<p>接下来，更多的是验证上述结论的正确性，目光转向下列方向：</p>
<ol>
<li>如果确定是端口耗尽导致的问题，手动构造场景是否可以复现这个问题？</li>
<li>工程是否真的有问题？因为也有可能是发起请求的组件存在问题。</li>
<li>bridge 模式在 Windows 上发起请求时的行为是否真的与上述一致？是否可以复现？是否有文档支撑？</li>
</ol>
<h3 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h3><p>有了猜想，想要复现问题其实比较容易，<a href="#windows-%E4%BE%A7%E5%8A%A8%E6%80%81%E7%AB%AF%E5%8F%A3%E8%8C%83%E5%9B%B4%E5%88%86%E6%9E%90">Windows 侧动态端口范围分析</a> 中提到，Windows 默认动态端口范围就是 16384 个，为了减少额外操作干扰，就不改动这个范围，直接手动打 16000 个连接看看问题能不能复现即可。</p>
<p>遂随便手搓了一对 server-client 脚本，server 甚至还有没办法退出的 bug（不过管他呢，反正也是复现问题用的，能跑就行）</p>
<p>client 可以手动通过 <code>open &lt;number&gt;</code> 或 <code>close &lt;number&gt;</code> 指定打开或关闭多少个连接，从而达到精确控制，免得开得不够多或者开得太多，主打一个灵活。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;server&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_client</span>(<span class="params">client_socket</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Handles a single client connection.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># Keep the connection alive</span></span><br><span class="line">            data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        client_socket.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_server</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Starts the TCP server.&quot;&quot;&quot;</span></span><br><span class="line">    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">23335</span>))</span><br><span class="line">    server.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Server listening on port 23335...&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client_socket, addr = server.accept()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Accepted connection from <span class="subst">&#123;addr&#125;</span>&quot;</span>)</span><br><span class="line">        client_handler = threading.Thread(target=handle_client, args=(client_socket,))</span><br><span class="line">        client_handler.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    start_server()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;client&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.connections = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">open_connections</span>(<span class="params">self, number</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Open a specified number of TCP connections.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(number):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">                <span class="comment"># client_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)  # Allow reuse of the address</span></span><br><span class="line">                client_socket.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">23335</span>))</span><br><span class="line">                <span class="variable language_">self</span>.connections.append(client_socket)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Opened connection <span class="subst">&#123;<span class="built_in">len</span>(self.connections)&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Failed to open connection: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close_connections</span>(<span class="params">self, number</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Close a specified number of TCP connections.&quot;&quot;&quot;</span></span><br><span class="line">        to_close = <span class="built_in">min</span>(number, <span class="built_in">len</span>(<span class="variable language_">self</span>.connections))</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(to_close):</span><br><span class="line">            client_socket = <span class="variable language_">self</span>.connections.pop()</span><br><span class="line">            client_socket.close()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Closed connection, <span class="subst">&#123;<span class="built_in">len</span>(self.connections)&#125;</span> remaining&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listen_for_input</span>(<span class="params">connection_manager</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Listens for user input to open/close connections.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        user_input = <span class="built_in">input</span>(<span class="string">&quot;Enter command (open &lt;number&gt; / close &lt;number&gt;): &quot;</span>)</span><br><span class="line">        parts = user_input.split()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(parts) != <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Invalid command. Use &#x27;open &lt;number&gt;&#x27; or &#x27;close &lt;number&gt;&#x27;.&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        command, number_str = parts</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            number = <span class="built_in">int</span>(number_str)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Please enter a valid number.&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> command == <span class="string">&quot;open&quot;</span>:</span><br><span class="line">            connection_manager.open_connections(number)</span><br><span class="line">        <span class="keyword">elif</span> command == <span class="string">&quot;close&quot;</span>:</span><br><span class="line">            connection_manager.close_connections(number)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Unknown command. Use &#x27;open&#x27; or &#x27;close&#x27;.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    connection_manager = ConnectionManager()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        listen_for_input(connection_manager)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\nExiting client.&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> conn <span class="keyword">in</span> connection_manager.connections:</span><br><span class="line">            conn.close()</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>测试发现，当打开了 16000 个端口左右再全部 close 后，问题确实可以复现。</p>
<p>为了交叉验证，在等待一段时间 （大概相当于第一个 open 的端口关闭 2 分钟后）问题自行消失并且在不另开新连接时不再复现。</p>
<p>同时，还通过设置 <code>SO_REUSEADDR</code> 标记进一步验证是因为 TIME_WAIT 端口无法被复用导致的问题，在设置该标记后，TIME_WAIT 阶段的端口可以被新的连接复用，实际测试反复开关连接超过 16000 次仍让不会导致问题复现。</p>
<p>至此，基本可以肯定问题出现的原因就是短连接过多导致 TIME_WAIT 堆积，最后动态端口耗尽无法创建新的连接使得 wda 请求失败。</p>
<h3 id="工程问题排查"><a href="#工程问题排查" class="headerlink" title="工程问题排查"></a>工程问题排查</h3><p>由于此处与工程相关逻辑强相关，不详细展开。经过代码 review，发现部分环节存在多次反复获取同一信息的问题，即有一些连续执行的逻辑链路 <code>A-B-C-D-E</code>，其中每一步都会请求 <code>get_necessary_data</code> 方法，由于五个方法分开实现，串联五个方法的代码作者与方法编写人又各不相同，没有注意到这里方法的反复多次冗余调用，最终导致了短时间高频调用的逻辑。暂时通过请求缓存优化后得以解除。</p>
<p>此处也佐证了高频的 wda 请求确实与工程的逻辑相关，进一步排除了底层工具链存在问题的可能性。</p>
<h3 id="Docker-在-Windows-下的网络驱动行为"><a href="#Docker-在-Windows-下的网络驱动行为" class="headerlink" title="Docker 在 Windows 下的网络驱动行为"></a>Docker 在 Windows 下的网络驱动行为</h3><p>在搜索引擎检索相关内容，发现并没有太多相关的内容，个人也没有找到官方有关上述发现的行为相关的文档。通过将 <a href="#%E9%97%AE%E9%A2%98%E5%A4%8D%E7%8E%B0">问题复现</a> 中的 client 代码搬到 docker 容器内执行并请求 <code>host.docker.internal</code> 地址，可以复现这种行为，也即容器内与 docker 网卡网关地址建立连接，宿主机上由 docker 发起另一段连接，并不直通，而在 Linux 上执行则可以看到不会有这样的行为。</p>
<p>在 Windows 上执行 <code>ipconfig</code> 同样也可以看到不会有 Linux 下执行 <code>ip a</code> 所看到的 <code>docker0</code> 或是 <code>vethX</code> 网卡，进一步推测两个平台上 docker 对于 bridge 网络驱动的实现方案不相同。</p>
<p>同时，我也对 gpt 进行了相关问题的询问，下面是 gpt 给出的解答，大家参考着看，不具有权威性：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[Prompt]</span><br><span class="line"></span><br><span class="line">I&#x27;m using docker on Windows, and I&#x27;m aware of a weird behavior:</span><br><span class="line"></span><br><span class="line">When I use host.docker.internal to access the host port, say, I try to connect to a tcp server listening on 0.0.0.0:23333 on host machine, I open a socket inside the container with the container ip:port as one end and host.docker.internal:23333 as the other.</span><br><span class="line"></span><br><span class="line">However, when I check the open connections on host, it shows that the just opened socket has 127.0.0.1:another port as on end and 127.0.0.1:23333 as the other. It seems that docker act as an intermediate, accept the connection to host.docker.internal and reopen one on host. Is this real and expected? Why is this behavior different than that on linux?</span><br><span class="line"></span><br><span class="line">Also, I&#x27;ve checked ipconfig on Windows and ifconfig on WSL, I can&#x27;t see any additional interfaces like `veth` or `docker0` or `br-xxx` as these interfaces exists on Linux</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line">[Answer]</span><br><span class="line"></span><br><span class="line">Yes, your observation about Docker&#x27;s behavior on Windows is correct and expected due to the differences in how Docker is implemented on Windows compared to Linux.</span><br><span class="line"></span><br><span class="line">### Docker Networking on Windows vs. Linux</span><br><span class="line"></span><br><span class="line">On Linux, Docker uses the host&#x27;s kernel features directly, such as namespaces and iptables, to manage containers. It creates virtual network interfaces (like `veth` pairs), bridges (`docker0`), and uses the native Linux networking stack. This setup allows containers to communicate with the host and each other in a manner that closely resembles how separate physical machines would interact on a network.</span><br><span class="line"></span><br><span class="line">On Windows, Docker operates differently because Windows does not natively support the same kernel-level features as Linux. Docker on Windows has two main modes: using Hyper-V (with Docker Desktop) or using the Windows Subsystem for Linux (WSL2). Each of these modes handles networking in its own way:</span><br><span class="line"></span><br><span class="line">1. **Hyper-V**: When using Docker Desktop with Hyper-V, Docker runs containers inside a lightweight virtual machine. All Docker networking goes through this VM. The `host.docker.internal` DNS name resolves to an internal gateway IP that Docker sets up to route traffic from the container to the host. This is why you see connections appearing to come from `127.0.0.1` on different ports; Docker is essentially NATing (Network Address Translation) the traffic between the container and the host.</span><br><span class="line"></span><br><span class="line">2. **WSL2**: In this mode, Docker utilizes a utility VM that runs a real Linux kernel, and Docker containers are managed much like they are on a native Linux system. However, the networking is still handled through a translation layer between Windows and the Linux kernel in WSL2, leading to similar behaviors as seen with Hyper-V.</span><br><span class="line"></span><br><span class="line">### Why the Difference?</span><br><span class="line"></span><br><span class="line">The primary reason for this difference is the underlying OS architecture and the lack of native container support in Windows. Docker must rely on virtualization and network translation to enable similar functionalities, which inherently changes how networking behaves.</span><br><span class="line"></span><br><span class="line">### Lack of `veth`, `docker0`, etc., on Windows</span><br><span class="line"></span><br><span class="line">As you&#x27;ve noticed, network interfaces like `veth`, `docker0`, or `br-xxx` are not visible on Windows. This is because these interfaces are part of the Linux networking architecture, which Windows does not natively support. Docker on Windows uses other methods (like creating a virtual network inside Hyper-V or leveraging the network stack in WSL2) to handle container networking.</span><br><span class="line"></span><br><span class="line">### Conclusion</span><br><span class="line"></span><br><span class="line">The behavior you&#x27;re seeing is expected given the architectural differences in how Docker operates on Windows versus Linux. Docker must adapt to the underlying operating system&#x27;s capabilities, leading to different networking setups and behaviors. If you need more consistent behavior across different OSes, you might consider using Linux VMs on Windows or deploying your Docker containers on native Linux systems.</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>问题的根因是工程逻辑变更后请求次数异常增加导致，直接原因是由于请求次数大量增加后，Windows 上动态端口耗尽触发了该报错，同时，docker 在 Windows 上的网络行为也进一步加剧了请求数量增长的影响（导致请求数量翻倍）。</p>
<p>由于 usbmuxd 和 docker 在 Windows 和 Linux 上行为的差异性导致了这个问题在 Linux 机器上无法复现，同时由于同一时间宿主机上任务负载量不同，导致了在同一个宿主机上也不能够稳定复现。通过手动构造极端场景可以做到稳定复现。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>找到了问题的原因，解决方案也就很明了了：</p>
<ol>
<li>优先级最高的就是直接干掉工程内部的逻辑了，通过优化掉工程的错误调用可以快速解决目前问题</li>
<li>考虑到后面宿主机仍有负载增长空间，代码编写也仍然不一定完美，可以通过调整 Windows 动态端口范围和直接从容器内访问 usbmuxd 服务来将允许的请求并发量提高大约 4 倍。</li>
</ol>
<p>此处额外解释一下第二点中为什么又可以直接从容器内访问 usbmuxd 了：前面发现容器内请求 <code>host.docker.internal</code> 会让 docker 以 <code>com.docker.backend.exe</code> 的身份使用 <code>127.0.0.1</code> 发起一个代理的请求，这还正好满足了 usbmuxd 只监听 <code>127.0.0.1:27015</code> 的行为了，这样宿主机的反代服务也就不需要了。</p>
<p>对于 Linux 服务，如果需要保持架构上的统一，一个可能的优化方向是将 usbmuxd 监听的 socket 映射到容器内？考虑到 docker daemon 的 socket 可以做到，大概这个方向也可行，但目前还没有做尝试，就留作一些可行的方案放在此处吧~</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.linloir.cn">Linloir</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.linloir.cn/2024/11/22/debug-windows-socket-drain/">https://blog.linloir.cn/2024/11/22/debug-windows-socket-drain/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.linloir.cn" target="_blank">時痕</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B7%A5%E4%BD%9C/">工作</a><a class="post-meta__tags" href="/tags/%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/">问题定位</a></div><div class="post-share"><div class="social-share" data-image="/img/cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/2024/12/31/summary-2023-2024/" title="年终总结 - 2023 至 2024"><img class="cover" src="/img/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">年终总结 - 2023 至 2024</div></div></a><a class="next-post pull-right" href="/2024/11/19/listary-quick-clone-command/" title="Listary 命令分享 - 快捷 clone 仓库并使用 VSCode 打开"><img class="cover" src="/img/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Listary 命令分享 - 快捷 clone 仓库并使用 VSCode 打开</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/2024/10/20/jar-via-adb/" title="用 adb + app_process 执行 Java 代码 —— 一种无需安装 apk 的脱机代码执行方案"><img class="cover" src="/img/cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-20</div><div class="title">用 adb + app_process 执行 Java 代码 —— 一种无需安装 apk 的脱机代码执行方案</div></div></a><a href="/2024/10/15/tencent-new-start/" title="短文 - 转正日"><img class="cover" src="/img/cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-15</div><div class="title">短文 - 转正日</div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Linloir</div><div class="author-info-description">我、技术、生活与值得分享的一切</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Linloir"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Linloir" target="_blank" title="GitHub"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:jonathanzhang.st@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">问题背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">定位过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A5%E9%94%99%E5%88%86%E6%9E%90"><span class="toc-number">2.1.</span> <span class="toc-text">报错分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%88%86%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">链路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-%E9%93%BE%E6%8E%A5%E5%88%86%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">tcp 链接分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows-%E4%BE%A7%E5%8A%A8%E6%80%81%E7%AB%AF%E5%8F%A3%E8%8C%83%E5%9B%B4%E5%88%86%E6%9E%90"><span class="toc-number">2.4.</span> <span class="toc-text">Windows 侧动态端口范围分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TIME-WAIT-%E6%BA%90%E5%A4%B4%E5%88%86%E6%9E%90"><span class="toc-number">2.5.</span> <span class="toc-text">TIME_WAIT 源头分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%A4%8D%E7%8E%B0"><span class="toc-number">2.6.</span> <span class="toc-text">问题复现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-number">2.7.</span> <span class="toc-text">工程问题排查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E5%9C%A8-Windows-%E4%B8%8B%E7%9A%84%E7%BD%91%E7%BB%9C%E9%A9%B1%E5%8A%A8%E8%A1%8C%E4%B8%BA"><span class="toc-number">2.8.</span> <span class="toc-text">Docker 在 Windows 下的网络驱动行为</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">4.</span> <span class="toc-text">解决方案</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/15/swift-develop-flutter-with-vscode/" title="Swift 学习笔记 - 配置 VS Code 开发 Flutter iOS Native 代码">Swift 学习笔记 - 配置 VS Code 开发 Flutter iOS Native 代码</a><time datetime="2025-05-15T01:53:53.000Z" title="发表于 2025-05-15 09:53:53">2025-05-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/12/swift-state-binding/" title="Swift 学习笔记 - 从 Property Wrapper 视角探索 State 与 Binding 如何工作">Swift 学习笔记 - 从 Property Wrapper 视角探索 State 与 Binding 如何工作</a><time datetime="2025-05-12T15:30:52.000Z" title="发表于 2025-05-12 23:30:52">2025-05-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/17/coroutine-llm-qa/" title="Coroutine 相关疑惑大模型问答记录">Coroutine 相关疑惑大模型问答记录</a><time datetime="2025-03-17T13:09:21.000Z" title="发表于 2025-03-17 21:09:21">2025-03-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/31/summary-2023-2024/" title="年终总结 - 2023 至 2024">年终总结 - 2023 至 2024</a><time datetime="2024-12-31T17:15:49.000Z" title="发表于 2025-01-01 01:15:49">2025-01-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/22/debug-windows-socket-drain/" title="问题定位回顾 - Windows 上发起 tcp 连接时提示 Only one usage of each socket address (protocol/network address/port) is normally permitted">问题定位回顾 - Windows 上发起 tcp 连接时提示 Only one usage of each socket address (protocol/network address/port) is normally permitted</a><time datetime="2024-11-22T03:52:37.000Z" title="发表于 2024-11-22 11:52:37">2024-11-22</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By Linloir</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Wirtten with Love ❤</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (true){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script id="canvas_nest" defer="defer" color="165,165,165" opacity="0.8" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>